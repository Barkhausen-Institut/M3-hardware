// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

module DivSqrtRawFN_small_1(
  input         clock,
                reset,
                io_inValid,
                io_sqrtOp,
                io_a_isNaN,
                io_a_isInf,
                io_a_isZero,
                io_a_sign,
  input  [12:0] io_a_sExp,
  input  [53:0] io_a_sig,
  input         io_b_isNaN,
                io_b_isInf,
                io_b_isZero,
                io_b_sign,
  input  [12:0] io_b_sExp,
  input  [53:0] io_b_sig,
  input  [2:0]  io_roundingMode,
  output        io_inReady,
                io_rawOutValid_div,
                io_rawOutValid_sqrt,
  output [2:0]  io_roundingModeOut,
  output        io_invalidExc,
                io_infiniteExc,
                io_rawOut_isNaN,
                io_rawOut_isInf,
                io_rawOut_isZero,
                io_rawOut_sign,
  output [12:0] io_rawOut_sExp,
  output [55:0] io_rawOut_sig
);

  reg  [5:0]  cycleNum;	// @[DivSqrtRecFN_small.scala:223:33]
  reg         inReady;	// @[DivSqrtRecFN_small.scala:224:33]
  reg         rawOutValid;	// @[DivSqrtRecFN_small.scala:225:33]
  reg         sqrtOp_Z;	// @[DivSqrtRecFN_small.scala:227:29]
  reg         majorExc_Z;	// @[DivSqrtRecFN_small.scala:228:29]
  reg         isNaN_Z;	// @[DivSqrtRecFN_small.scala:230:29]
  reg         isInf_Z;	// @[DivSqrtRecFN_small.scala:231:29]
  reg         isZero_Z;	// @[DivSqrtRecFN_small.scala:232:29]
  reg         sign_Z;	// @[DivSqrtRecFN_small.scala:233:29]
  reg  [12:0] sExp_Z;	// @[DivSqrtRecFN_small.scala:234:29]
  reg  [52:0] fractB_Z;	// @[DivSqrtRecFN_small.scala:235:29]
  reg  [2:0]  roundingMode_Z;	// @[DivSqrtRecFN_small.scala:236:29]
  reg  [54:0] rem_Z;	// @[DivSqrtRecFN_small.scala:242:29]
  reg         notZeroRem_Z;	// @[DivSqrtRecFN_small.scala:243:29]
  reg  [54:0] sigX_Z;	// @[DivSqrtRecFN_small.scala:244:29]
  wire        specialCaseA_S = io_a_isNaN | io_a_isInf | io_a_isZero;	// @[DivSqrtRecFN_small.scala:272:55]
  wire        normalCase_S = io_sqrtOp ? ~specialCaseA_S & ~io_a_sign : ~specialCaseA_S & ~(io_b_isNaN | io_b_isInf | io_b_isZero);	// @[DivSqrtRecFN_small.scala:272:55, :273:55, :274:{28,45,48}, :275:{46,49}, :276:27]
  wire        skipCycle2 = cycleNum == 6'h3 & sigX_Z[54];	// @[DivSqrtRecFN_small.scala:223:33, :244:29, :300:{31,39,48}]
  wire        notSigNaNIn_invalidExc_S_sqrt = ~io_a_isNaN & ~io_a_isZero & io_a_sign;	// @[DivSqrtRecFN_small.scala:255:{9,27,43}]
  wire        notSigNaNIn_invalidExc_S_div = io_a_isZero & io_b_isZero | io_a_isInf & io_b_isInf;	// @[DivSqrtRecFN_small.scala:253:{24,42,59}]
  wire [13:0] sExpQuot_S_div = {io_a_sExp[12], io_a_sExp} + {{3{io_b_sExp[11]}}, ~(io_b_sExp[10:0])};	// @[DivSqrtRecFN_small.scala:279:21, :280:{28,40,52}]
  wire        _fractB_Z_T_10 = inReady & io_sqrtOp;	// @[DivSqrtRecFN_small.scala:224:33, :342:25]
  wire [51:0] _fractB_Z_T_25 = inReady ? 52'h0 : fractB_Z[52:1];	// @[DivSqrtRecFN_small.scala:224:33, :235:29, :342:16, :345:{16,71}]
  wire [63:0] _bitMask_T = 64'h1 << cycleNum;	// @[DivSqrtRecFN_small.scala:223:33, :359:23]
  wire        oddSqrt_S = io_sqrtOp & io_a_sExp[0];	// @[DivSqrtRecFN_small.scala:290:48, :291:32]
  wire        entering = inReady & io_inValid;	// @[DivSqrtRecFN_small.scala:224:33, :296:28]
  wire        _sigX_Z_T_7 = inReady & oddSqrt_S;	// @[DivSqrtRecFN_small.scala:224:33, :291:32, :352:21]
  wire [55:0] rem = {1'h0, inReady & ~oddSqrt_S ? {io_a_sig, 1'h0} : 55'h0} | (_sigX_Z_T_7 ? {io_a_sig[52:51] - 2'h1, io_a_sig[50:0], 3'h0} : 56'h0) | (inReady ? 56'h0 : {rem_Z, 1'h0});	// @[Cat.scala:33:92, DivSqrtRecFN_small.scala:224:33, :225:33, :242:29, :291:32, :351:{12,21,24,47,57}, :352:{12,21}, :353:{27,56}, :354:{27,44}, :357:11, :358:{12,29}]
  wire [57:0] trialRem = {2'h0, rem} - {2'h0, {1'h0, (inReady & ~io_sqrtOp ? {io_b_sig, 1'h0} : 55'h0) | (_sigX_Z_T_7 ? 55'h50000000000000 : 55'h0) | {1'h0, inReady & io_sqrtOp & ~(io_a_sExp[0]) | ~inReady & ~sqrtOp_Z, inReady ? 53'h0 : fractB_Z}} | (~inReady & sqrtOp_Z ? {sigX_Z, 1'h0} : 56'h0)};	// @[DivSqrtRecFN_small.scala:224:33, :225:33, :227:29, :235:29, :244:29, :270:33, :290:{35,48}, :339:23, :341:16, :351:12, :352:{12,21}, :353:56, :357:11, :361:{12,21,48}, :362:21, :363:12, :364:{12,74}, :365:{23,26,74}, :366:{12,23,44}, :367:29]
  wire        newBit = $signed(trialRem) > -58'sh1;	// @[DivSqrtRecFN_small.scala:367:29, :368:23]
  wire        _T_6 = entering | ~inReady;	// @[DivSqrtRecFN_small.scala:224:33, :296:28, :339:23, :389:20]
  always @(posedge clock) begin
    if (reset) begin
      cycleNum <= 6'h0;	// @[DivSqrtRecFN_small.scala:223:33]
      inReady <= 1'h1;	// @[DivSqrtRecFN_small.scala:224:33]
      rawOutValid <= 1'h0;	// @[DivSqrtRecFN_small.scala:225:33]
    end
    else if ((|cycleNum) | entering) begin	// @[DivSqrtRecFN_small.scala:223:33, :295:25, :296:28, :302:18]
      cycleNum <= (entering & normalCase_S ? (io_sqrtOp ? (io_a_sExp[0] ? 6'h35 : 6'h36) : 6'h37) : 6'h0) | (entering | skipCycle2 ? 6'h0 : cycleNum - 6'h1) | {5'h0, entering & ~normalCase_S | skipCycle2};	// @[DivSqrtRecFN_small.scala:223:33, :276:27, :290:48, :296:28, :297:40, :300:39, :304:{26,28}, :305:16, :306:20, :307:24, :312:{16,56,95}, :316:38]
      inReady <= entering & ~normalCase_S | ~entering & ~skipCycle2 & cycleNum - 6'h1 < 6'h2 | skipCycle2;	// @[DivSqrtRecFN_small.scala:223:33, :224:33, :276:27, :296:28, :300:39, :304:{26,28}, :312:{16,17,31,56,95}, :316:38]
      rawOutValid <= entering & ~normalCase_S | ~entering & ~skipCycle2 & cycleNum - 6'h1 == 6'h1 | skipCycle2;	// @[DivSqrtRecFN_small.scala:223:33, :225:33, :276:27, :296:28, :300:39, :304:{26,28}, :312:{16,17,31,56,95}, :316:38, :317:42]
    end
    if (entering) begin	// @[DivSqrtRecFN_small.scala:296:28]
      sqrtOp_Z <= io_sqrtOp;	// @[DivSqrtRecFN_small.scala:227:29]
      if (io_sqrtOp) begin
        majorExc_Z <= io_a_isNaN & ~(io_a_sig[51]) | notSigNaNIn_invalidExc_S_sqrt;	// @[DivSqrtRecFN_small.scala:228:29, :255:43, :258:38, common.scala:82:{46,49,56}]
        isNaN_Z <= io_a_isNaN | notSigNaNIn_invalidExc_S_sqrt;	// @[DivSqrtRecFN_small.scala:230:29, :255:43, :265:26]
        sExp_Z <= {io_a_sExp[12], io_a_sExp[12:1]} + 13'h400;	// @[DivSqrtRecFN_small.scala:234:29, :279:21, :334:{29,34}]
      end
      else begin
        majorExc_Z <= io_a_isNaN & ~(io_a_sig[51]) | io_b_isNaN & ~(io_b_sig[51]) | notSigNaNIn_invalidExc_S_div | ~io_a_isNaN & ~io_a_isInf & io_b_isZero;	// @[DivSqrtRecFN_small.scala:228:29, :253:42, :255:9, :260:46, :261:{36,51}, common.scala:82:{46,49,56}]
        isNaN_Z <= io_a_isNaN | io_b_isNaN | notSigNaNIn_invalidExc_S_div;	// @[DivSqrtRecFN_small.scala:230:29, :253:42, :266:42]
        sExp_Z <= {$signed(sExpQuot_S_div) > 14'shDFF ? 4'h6 : sExpQuot_S_div[12:9], sExpQuot_S_div[8:0]};	// @[Cat.scala:33:92, DivSqrtRecFN_small.scala:234:29, :279:21, :283:{16,48}, :285:31, :287:27]
      end
      isInf_Z <= ~io_sqrtOp & io_b_isZero | io_a_isInf;	// @[DivSqrtRecFN_small.scala:231:29, :268:23]
      isZero_Z <= ~io_sqrtOp & io_b_isInf | io_a_isZero;	// @[DivSqrtRecFN_small.scala:232:29, :268:23, :269:23]
      sign_Z <= io_a_sign ^ ~io_sqrtOp & io_b_sign;	// @[DivSqrtRecFN_small.scala:233:29, :270:{30,33,45}]
      roundingMode_Z <= io_roundingMode;	// @[DivSqrtRecFN_small.scala:236:29]
    end
    if (entering | ~inReady & sqrtOp_Z)	// @[DivSqrtRecFN_small.scala:224:33, :227:29, :296:28, :339:{20,23,33}]
      fractB_Z <= (inReady & ~io_sqrtOp ? {io_b_sig[51:0], 1'h0} : 53'h0) | {_fractB_Z_T_10 & ~(io_a_sExp[0]), _fractB_Z_T_10 & io_a_sExp[0] | _fractB_Z_T_25[51], _fractB_Z_T_25[50:0]};	// @[DivSqrtRecFN_small.scala:224:33, :225:33, :235:29, :270:33, :290:48, :341:{16,25,73,90}, :342:{25,38}, :343:{38,41}, :344:100, :345:16]
    if (_T_6) begin	// @[DivSqrtRecFN_small.scala:389:20]
      rem_Z <= newBit ? trialRem[54:0] : rem[54:0];	// @[DivSqrtRecFN_small.scala:242:29, :357:11, :367:29, :368:23, :370:24]
      sigX_Z <= (inReady & ~io_sqrtOp ? {newBit, 54'h0} : 55'h0) | {1'h0, inReady & io_sqrtOp, _sigX_Z_T_7 ? {newBit, 52'h0} : 53'h0} | (inReady ? 55'h0 : sigX_Z) | (~inReady & newBit ? _bitMask_T[56:2] : 55'h0);	// @[DivSqrtRecFN_small.scala:224:33, :225:33, :244:29, :270:33, :339:23, :341:16, :342:16, :351:12, :352:21, :359:{23,34}, :362:12, :368:23, :393:{16,25,50}, :394:{25,74}, :395:{16,50}, :396:{16,74}, :397:{16,27}]
    end
    if (_T_6 & (inReady | newBit))	// @[DivSqrtRecFN_small.scala:224:33, :243:29, :368:23, :379:{31,40}, :389:{20,34}, :390:22]
      notZeroRem_Z <= |trialRem;	// @[DivSqrtRecFN_small.scala:243:29, :367:29, :379:60]
  end // always @(posedge)
  `ifndef SYNTHESIS
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM_0;
    logic [31:0] _RANDOM_1;
    logic [31:0] _RANDOM_2;
    logic [31:0] _RANDOM_3;
    logic [31:0] _RANDOM_4;
    logic [31:0] _RANDOM_5;
    logic [31:0] _RANDOM_6;
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM_0 = `RANDOM;
        _RANDOM_1 = `RANDOM;
        _RANDOM_2 = `RANDOM;
        _RANDOM_3 = `RANDOM;
        _RANDOM_4 = `RANDOM;
        _RANDOM_5 = `RANDOM;
        _RANDOM_6 = `RANDOM;
        cycleNum = _RANDOM_0[5:0];	// @[DivSqrtRecFN_small.scala:223:33]
        inReady = _RANDOM_0[6];	// @[DivSqrtRecFN_small.scala:223:33, :224:33]
        rawOutValid = _RANDOM_0[7];	// @[DivSqrtRecFN_small.scala:223:33, :225:33]
        sqrtOp_Z = _RANDOM_0[8];	// @[DivSqrtRecFN_small.scala:223:33, :227:29]
        majorExc_Z = _RANDOM_0[9];	// @[DivSqrtRecFN_small.scala:223:33, :228:29]
        isNaN_Z = _RANDOM_0[10];	// @[DivSqrtRecFN_small.scala:223:33, :230:29]
        isInf_Z = _RANDOM_0[11];	// @[DivSqrtRecFN_small.scala:223:33, :231:29]
        isZero_Z = _RANDOM_0[12];	// @[DivSqrtRecFN_small.scala:223:33, :232:29]
        sign_Z = _RANDOM_0[13];	// @[DivSqrtRecFN_small.scala:223:33, :233:29]
        sExp_Z = _RANDOM_0[26:14];	// @[DivSqrtRecFN_small.scala:223:33, :234:29]
        fractB_Z = {_RANDOM_0[31:27], _RANDOM_1, _RANDOM_2[15:0]};	// @[DivSqrtRecFN_small.scala:223:33, :235:29]
        roundingMode_Z = _RANDOM_2[18:16];	// @[DivSqrtRecFN_small.scala:235:29, :236:29]
        rem_Z = {_RANDOM_2[31:19], _RANDOM_3, _RANDOM_4[9:0]};	// @[DivSqrtRecFN_small.scala:235:29, :242:29]
        notZeroRem_Z = _RANDOM_4[10];	// @[DivSqrtRecFN_small.scala:242:29, :243:29]
        sigX_Z = {_RANDOM_4[31:11], _RANDOM_5, _RANDOM_6[1:0]};	// @[DivSqrtRecFN_small.scala:242:29, :244:29]
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // not def SYNTHESIS
  assign io_inReady = inReady;	// @[DivSqrtRecFN_small.scala:224:33]
  assign io_rawOutValid_div = rawOutValid & ~sqrtOp_Z;	// @[DivSqrtRecFN_small.scala:225:33, :227:29, :365:26, :403:40]
  assign io_rawOutValid_sqrt = rawOutValid & sqrtOp_Z;	// @[DivSqrtRecFN_small.scala:225:33, :227:29, :404:40]
  assign io_roundingModeOut = roundingMode_Z;	// @[DivSqrtRecFN_small.scala:236:29]
  assign io_invalidExc = majorExc_Z & isNaN_Z;	// @[DivSqrtRecFN_small.scala:228:29, :230:29, :406:36]
  assign io_infiniteExc = majorExc_Z & ~isNaN_Z;	// @[DivSqrtRecFN_small.scala:228:29, :230:29, :407:{36,39}]
  assign io_rawOut_isNaN = isNaN_Z;	// @[DivSqrtRecFN_small.scala:230:29]
  assign io_rawOut_isInf = isInf_Z;	// @[DivSqrtRecFN_small.scala:231:29]
  assign io_rawOut_isZero = isZero_Z;	// @[DivSqrtRecFN_small.scala:232:29]
  assign io_rawOut_sign = sign_Z;	// @[DivSqrtRecFN_small.scala:233:29]
  assign io_rawOut_sExp = sExp_Z;	// @[DivSqrtRecFN_small.scala:234:29]
  assign io_rawOut_sig = {sigX_Z, notZeroRem_Z};	// @[DivSqrtRecFN_small.scala:243:29, :244:29, :413:35]
endmodule

